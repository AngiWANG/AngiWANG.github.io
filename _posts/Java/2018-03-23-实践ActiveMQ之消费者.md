---
layout: post
title: "实践ActiveMQ之消费者"
date: 2018-03-21 11:08:00 +0800
categories: Java
tags: java JMS ActiveMQ
---



预读取（jms.prefetchPolicy.queuePrefetch，默认值1000，必须大于等于0）

## 同步receive消费

```java
private JmsTemplate jmsTemplate;
TextMessage message = (TextMessage) jmsTemplate.receive();
```

##异步监听消费

### 基于Spring JMS之DefaultMessageListenerContainer

```xml
<bean id="queueListenerContainer"
		class="org.springframework.jms.listener.DefaultMessageListenerContainer">
	<property name="connectionFactory" ref="jmsConnectionFactory" />
	<property name="destinationName" value="queue123" />
	<property name="messageListener" ref="simpleMessageListener" />
	<property name="concurrentConsumers" value="5" />
	<property name="maxConcurrentConsumers" value="20" />
</bean>
```

消费者数量动态调整（concurrentConsumers和maxConcurrentConsumers之间）

消费者监听器以线程名`queueListenerContainer-N`执行，setReceiveTimeout（可以理解为keepalived，默认值为-1）和setMaxMessagesPerTask（最多处理消息数，默认值为java.lang.Integer#MIN_VALUE）决定释放与否，默认情况下不释放

### 自定义监听容器

```java
while (i < maxConcurrentConsumers) {
	Session session = connection.createSession(transacted, acknowledgeMode);
	sessions.add(session);
	MessageConsumer messageConsumer = session.createConsumer(destination);
	messageConsumers.add(messageConsumer);
	messageConsumer.setMessageListener(messageListener);
}
```

`ActiveMQSession`实现了接口`ActiveMQDispatcher`，一个`ActiveMQSession`持有一个`ActiveMQSessionExecutor`，一个Session下创建多个Consumer则会串行处理

消费者监听器以线程名`ActiveMQ Session Task-N`执行